
# OverVIew

- Dockerfile is programmatically define steps for the creation of Docker images, and creates individual images for each instruction


# Details
![Pasted image 20250325204440.png](./Pasted%20image%2020250325204440.png)

Dockerfile - programmatically define steps for the creation of Docker images

==> reproducibility - by defining all the steps neceaaray to build your Docker images, you ensure that anyone with the Dockerfile can recreate the exact same image.
==> Automation - by! Step!
==> transparency and documentation - Dockerfiles should act as good documentation ...
==> Optimization - Since Dockerfiles provide you full control over the build step, you can tackle into optimizations to improve security and speed up build time and image size

Docker file 
        comments
		From (base-image)      ==> made base image hased idividual image ID
		Instruction1 arg arg      ==> that is new image ,made by base image and Instruction  also has idividual image id, but base image dosen't disappear
		Cmd [...]                        


Details

# COPY명령어

```bash
FROM nginx:1.27.0

RUN apt-get update
RUN apt-get -y install vim

# /usr/share/nginx/html/index.html

# COPY source destination
COPY testIndex.html /usr/share/nginx/html/index.html
```

- COPY '[source]'  '[destination]' => source의 파일을 destination 파일로 붙여넣기
- 더 나아가기 ) 이 source 와 데스티네이션의 경로를 어떻게 작성하는지 확인하자
  우선 testIndex.html 은 Dockerfile 하고 같은 경로라서 별다른 문자열이 없고
  nginx 컨테이너는 / 로 시작 됐음을 알수 있다. 

```bash
jaebukbuk@jaebukbukubuntu24:~$ docker build -t web_server_image .
[+] Building 1.8s (10/10) FINISHED                        docker:default
 => [internal] load build definition from Dockerfile       0.0s
 => => transferring dockerfile: 221B                       0.0s 
 => [1/4] FROM docker.io/library/nginx:1.27.0@sha256:98f8ec75657d21b924fe4f69b6b9bff2f6550ea48838af479d8894a852000e40                    0.0s 
 => CACHED [2/4] RUN apt-get update             0.0s
 => CACHED [3/4] RUN apt-get -y install vim     0.0s
 => [4/4] COPY testIndex.html /usr/share/nginx/html/index.html     0.0s
 => exporting to image                                             0.0s
 => => exporting layers                                            0.0s
 => => writing image sha256:f634073ffc7af1cadf312777ad74ccf8b8062a25a8cd91076eb10947c367f699
 => => naming to docker.io/library/web_server_image                0.0s
```

- copy 가 정상적으로 동작 한것을 알수 있다.
- 하지만 오너쉽 문제로 해당 명령어가 실패할수이쓴데

```bash
# 이게 권한 문제 때문에 안될때
RUN chown nginx:nginx /usr/share/nginx/html/index.html
```

- 이때는 해당 권한 부여해 주자 user:group

# OverVIew

- Dockerfile is programmatically define steps for the creation of Docker images, and creates individual images for each instruction


# Details
![Pasted image 20250325204440.png](./Pasted%20image%2020250325204440.png)

Dockerfile - programmatically define steps for the creation of Docker images

==> reproducibility - by defining all the steps neceaaray to build your Docker images, you ensure that anyone with the Dockerfile can recreate the exact same image.
==> Automation - by! Step!
==> transparency and documentation - Dockerfiles should act as good documentation ...
==> Optimization - Since Dockerfiles provide you full control over the build step, you can tackle into optimizations to improve security and speed up build time and image size

Docker file 
        comments
		From (base-image)      ==> made base image hased idividual image ID
		Instruction1 arg arg      ==> that is new image ,made by base image and Instruction  also has idividual image id, but base image dosen't disappear
		Cmd [...]                        


Details

# COPY명령어

```bash
FROM nginx:1.27.0

RUN apt-get update
RUN apt-get -y install vim

# /usr/share/nginx/html/index.html

# COPY source destination
COPY testIndex.html /usr/share/nginx/html/index.html
```

- COPY '[source]'  '[destination]' => source의 파일을 destination 파일로 붙여넣기
- 더 나아가기 ) 이 source 와 데스티네이션의 경로를 어떻게 작성하는지 확인하자
  우선 testIndex.html 은 Dockerfile 하고 같은 경로라서 별다른 문자열이 없고
  nginx 컨테이너는 / 로 시작 됐음을 알수 있다. 

```bash
jaebukbuk@jaebukbukubuntu24:~$ docker build -t web_server_image .
[+] Building 1.8s (10/10) FINISHED                        docker:default
 => [internal] load build definition from Dockerfile       0.0s
 => => transferring dockerfile: 221B                       0.0s 
 => [1/4] FROM docker.io/library/nginx:1.27.0@sha256:98f8ec75657d21b924fe4f69b6b9bff2f6550ea48838af479d8894a852000e40                    0.0s 
 => CACHED [2/4] RUN apt-get update             0.0s
 => CACHED [3/4] RUN apt-get -y install vim     0.0s
 => [4/4] COPY testIndex.html /usr/share/nginx/html/index.html     0.0s
 => exporting to image                                             0.0s
 => => exporting layers                                            0.0s
 => => writing image sha256:f634073ffc7af1cadf312777ad74ccf8b8062a25a8cd91076eb10947c367f699
 => => naming to docker.io/library/web_server_image                0.0s
```

- copy 가 정상적으로 동작 한것을 알수 있다.
- 하지만 오너쉽 문제로 해당 명령어가 실패할수이쓴데

```bash
# 이게 권한 문제 때문에 안될때
RUN chown nginx:nginx /usr/share/nginx/html/index.html
```

- 이때는 해당 권한 부여해 주자 user:group

# Sub Tages

| 하위 태그 | 태그 페이지 | 하위 페이지 수 |
| ----- | ------ | -------- |

```text
table Without Id
      tags                                        as "하위 태그"
    ,  link( substring(replace(tags,"/"," "), 1)) as "태그 페이지"
    , length(rows.file.link)                      as "하위 페이지 수"
FROM ""
FLATTEN file.tags AS tags 
WHERE file.tags
  and contains(tags,"Project/개발활동/개인서버구축/Docker강의/")
GROUP BY tags
SORT length(rows.file.link) DESC
```
# All Sub Tag Pages

| 하위 태그 파일 | 하위 태그 | 하위 태그 페이지 | 생성일 |
| -------- | ----- | --------- | --- |
| 하위 태그 파일 | 하위 태그 | 하위 태그 페이지 | 생성일 |
| -------- | ----- | --------- | --- |



```text
TABLE Without ID
      link(file.name)                          as "하위 태그 파일"
    , "#"+etag                                 as "하위 태그"
    , link( replace(etag,"/", " ") )           as "하위 태그 페이지"
    , dateformat(file.ctime, "yyyy-MM-dd")     as "생성일"
FROM ""
FLATTEN substring(file.etags, 1) as etag
where contains(etag, "Project/개발활동/개인서버구축/Docker강의/")
SORT etag, file.ctime desc
```


| Tags | Folder | Files |
| ---- | ------ | ----- |

```text
TABLE WITHOUT ID (tag + "(" + length(rows.file.link) + ")") AS Tags, join(rows.file.folder) AS Folder, join(rows.file.link, ", ") AS Files
FROM ""
WHERE file.tags
FLATTEN file.tags AS tag
GROUP BY tag
SORT length(rows.file.link) DESC
```
## [🐤HomePage](%F0%9F%90%A4HomePage.md) main dataView

| TagPage | search_Tag | file |
| ------- | ---------- | ---- |

```text
table without id
link( substring(replace(tags,"/"," "), 1)) as TagPage
   , tags as search_Tag
   , file
FROM ""
WHERE file.tags
FLATTEN file.tags AS tags 
GROUP BY tags
SORT length(rows.file.link) DESC
```

## tag page number
| tag | Number |
| --- | ------ |

```text
TABLE 
length(rows.file.link) as "Number"
FLATTEN file.tags as tag
GROUP BY tag
```
## tag page number
| aliases | aliases | files.link |
| ------- | ------- | ---------- |

```text
TABLE 
  aliases
, files.link
FLATTEN file as files
FLATTEN file.aliases as aliases
GROUP BY aliases
```
## tag page number
| File | file.name | file.link |
| ---- | --------- | --------- |

```text
TABLE 
  file.name
, file.link
from ""
where length(file.aliases) > 0
```
## 파일 객체 

| File | file |
| ---- | ---- |


```text
table file
where file.name ="Project"
```

## 맵을 이용한 예제인데 잘모르겠음


| File                                                   | file.tags | file.etags | any(mappedTags) | all(mappedTags) |
| ------------------------------------------------------ | --------- | ---------- | --------------- | --------------- |
| [DataView practice](./DataView%2520practice.md#) | <ul></ul> | <ul></ul>  | false           | true            |
| [옵시디언 사용 예제](%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%2520%EC%82%AC%EC%9A%A9%2520%EC%98%88%EC%A0%9C.md#)               | <ul></ul> | <ul></ul>  | false           | true            |
| [무제](./%EB%AC%B4%EC%A0%9C.md)                                          | <ul></ul> | <ul></ul>  | false           | true            |


```text
TABLE file.tags, file.etags, any(mappedTags), all(mappedTags)
  
FROM ""
FLATTEN list( map(this.file.etags, (tag) => contains(file.etags, tag))) as mappedTags
LIMIT 20
```

## 태그 이름 조작
| Tags | Folder | Files |
| ---- | ------ | ----- |


```text
table WITHOUT ID (tag + "(" + length(rows.file.link) + ")") AS Tags, join(rows.file.folder) AS Folder, join(rows.file.link, ", ") AS Files
FROM ""
WHERE contains(tags, "#Project")
FLATTEN file.tags AS tag
GROUP BY tag
SORT length(rows.file.link) DESC
```
## 태그 레벨 확인

| File | etag | level |
| ---- | ---- | ----- |

```text
TABLE etag, level 
FROM ""
FLATTEN substring(file.etags, 1) as etag
FLATTEN split(etag, "/") as level
 
```

# Sub Tages

| 하위 태그 | 태그 페이지 | 하위 페이지 수 |
| ----- | ------ | -------- |

```text
table Without Id
      tags                                        as "하위 태그"
    ,  link( substring(replace(tags,"/"," "), 1)) as "태그 페이지"
    , length(rows.file.link)                      as "하위 페이지 수"
FROM ""
FLATTEN file.tags AS tags 
WHERE file.tags
  and contains(tags,"Project/개발활동/개인서버구축/Docker강의/")
GROUP BY tags
SORT length(rows.file.link) DESC
```
# All Sub Tag Pages

| 하위 태그 파일 | 하위 태그 | 하위 태그 페이지 | 생성일 |
| -------- | ----- | --------- | --- |
| 하위 태그 파일 | 하위 태그 | 하위 태그 페이지 | 생성일 |
| -------- | ----- | --------- | --- |



```text
TABLE Without ID
      link(file.name)                          as "하위 태그 파일"
    , "#"+etag                                 as "하위 태그"
    , link( replace(etag,"/", " ") )           as "하위 태그 페이지"
    , dateformat(file.ctime, "yyyy-MM-dd")     as "생성일"
FROM ""
FLATTEN substring(file.etags, 1) as etag
where contains(etag, "Project/개발활동/개인서버구축/Docker강의/")
SORT etag, file.ctime desc
```


| Tags | Folder | Files |
| ---- | ------ | ----- |

```text
TABLE WITHOUT ID (tag + "(" + length(rows.file.link) + ")") AS Tags, join(rows.file.folder) AS Folder, join(rows.file.link, ", ") AS Files
FROM ""
WHERE file.tags
FLATTEN file.tags AS tag
GROUP BY tag
SORT length(rows.file.link) DESC
```
## [🐤HomePage](%F0%9F%90%A4HomePage.md) main dataView

| TagPage | search_Tag | file |
| ------- | ---------- | ---- |

```text
table without id
link( substring(replace(tags,"/"," "), 1)) as TagPage
   , tags as search_Tag
   , file
FROM ""
WHERE file.tags
FLATTEN file.tags AS tags 
GROUP BY tags
SORT length(rows.file.link) DESC
```

## tag page number
| tag | Number |
| --- | ------ |

```text
TABLE 
length(rows.file.link) as "Number"
FLATTEN file.tags as tag
GROUP BY tag
```
## tag page number
| aliases | aliases | files.link |
| ------- | ------- | ---------- |

```text
TABLE 
  aliases
, files.link
FLATTEN file as files
FLATTEN file.aliases as aliases
GROUP BY aliases
```
## tag page number
| File | file.name | file.link |
| ---- | --------- | --------- |

```text
TABLE 
  file.name
, file.link
from ""
where length(file.aliases) > 0
```
## 파일 객체 

| File | file |
| ---- | ---- |


```text
table file
where file.name ="Project"
```

## 맵을 이용한 예제인데 잘모르겠음


| File                                                   | file.tags | file.etags | any(mappedTags) | all(mappedTags) |
| ------------------------------------------------------ | --------- | ---------- | --------------- | --------------- |
| [DataView practice](./DataView%2520practice.md#) | <ul></ul> | <ul></ul>  | false           | true            |
| [옵시디언 사용 예제](%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%2520%EC%82%AC%EC%9A%A9%2520%EC%98%88%EC%A0%9C.md#)               | <ul></ul> | <ul></ul>  | false           | true            |
| [무제](./%EB%AC%B4%EC%A0%9C.md)                                          | <ul></ul> | <ul></ul>  | false           | true            |


```text
TABLE file.tags, file.etags, any(mappedTags), all(mappedTags)
  
FROM ""
FLATTEN list( map(this.file.etags, (tag) => contains(file.etags, tag))) as mappedTags
LIMIT 20
```

## 태그 이름 조작
| Tags | Folder | Files |
| ---- | ------ | ----- |


```text
table WITHOUT ID (tag + "(" + length(rows.file.link) + ")") AS Tags, join(rows.file.folder) AS Folder, join(rows.file.link, ", ") AS Files
FROM ""
WHERE contains(tags, "#Project")
FLATTEN file.tags AS tag
GROUP BY tag
SORT length(rows.file.link) DESC
```
## 태그 레벨 확인

| File | etag | level |
| ---- | ---- | ----- |

```text
TABLE etag, level 
FROM ""
FLATTEN substring(file.etags, 1) as etag
FLATTEN split(etag, "/") as level
 
```

# OverVIew

- Dockerfile is programmatically define steps for the creation of Docker images, and creates individual images for each instruction


# Details
![Pasted image 20250325204440.png](./Pasted%20image%2020250325204440.png)

Dockerfile - programmatically define steps for the creation of Docker images

==> reproducibility - by defining all the steps neceaaray to build your Docker images, you ensure that anyone with the Dockerfile can recreate the exact same image.
==> Automation - by! Step!
==> transparency and documentation - Dockerfiles should act as good documentation ...
==> Optimization - Since Dockerfiles provide you full control over the build step, you can tackle into optimizations to improve security and speed up build time and image size

Docker file 
        comments
		From (base-image)      ==> made base image hased idividual image ID
		Instruction1 arg arg      ==> that is new image ,made by base image and Instruction  also has idividual image id, but base image dosen't disappear
		Cmd [...]                        


Details

# COPY명령어

```bash
FROM nginx:1.27.0

RUN apt-get update
RUN apt-get -y install vim

# /usr/share/nginx/html/index.html

# COPY source destination
COPY testIndex.html /usr/share/nginx/html/index.html
```

- COPY '[source]'  '[destination]' => source의 파일을 destination 파일로 붙여넣기
- 더 나아가기 ) 이 source 와 데스티네이션의 경로를 어떻게 작성하는지 확인하자
  우선 testIndex.html 은 Dockerfile 하고 같은 경로라서 별다른 문자열이 없고
  nginx 컨테이너는 / 로 시작 됐음을 알수 있다. 

```bash
jaebukbuk@jaebukbukubuntu24:~$ docker build -t web_server_image .
[+] Building 1.8s (10/10) FINISHED                        docker:default
 => [internal] load build definition from Dockerfile       0.0s
 => => transferring dockerfile: 221B                       0.0s 
 => [1/4] FROM docker.io/library/nginx:1.27.0@sha256:98f8ec75657d21b924fe4f69b6b9bff2f6550ea48838af479d8894a852000e40                    0.0s 
 => CACHED [2/4] RUN apt-get update             0.0s
 => CACHED [3/4] RUN apt-get -y install vim     0.0s
 => [4/4] COPY testIndex.html /usr/share/nginx/html/index.html     0.0s
 => exporting to image                                             0.0s
 => => exporting layers                                            0.0s
 => => writing image sha256:f634073ffc7af1cadf312777ad74ccf8b8062a25a8cd91076eb10947c367f699
 => => naming to docker.io/library/web_server_image                0.0s
```

- copy 가 정상적으로 동작 한것을 알수 있다.
- 하지만 오너쉽 문제로 해당 명령어가 실패할수이쓴데

```bash
# 이게 권한 문제 때문에 안될때
RUN chown nginx:nginx /usr/share/nginx/html/index.html
```

- 이때는 해당 권한 부여해 주자 user:group

# OverVIew

- Dockerfile is programmatically define steps for the creation of Docker images, and creates individual images for each instruction


# Details
![Pasted image 20250325204440.png](./Pasted%20image%2020250325204440.png)

Dockerfile - programmatically define steps for the creation of Docker images

==> reproducibility - by defining all the steps neceaaray to build your Docker images, you ensure that anyone with the Dockerfile can recreate the exact same image.
==> Automation - by! Step!
==> transparency and documentation - Dockerfiles should act as good documentation ...
==> Optimization - Since Dockerfiles provide you full control over the build step, you can tackle into optimizations to improve security and speed up build time and image size

Docker file 
        comments
		From (base-image)      ==> made base image hased idividual image ID
		Instruction1 arg arg      ==> that is new image ,made by base image and Instruction  also has idividual image id, but base image dosen't disappear
		Cmd [...]                        


Details

# COPY명령어

```bash
FROM nginx:1.27.0

RUN apt-get update
RUN apt-get -y install vim

# /usr/share/nginx/html/index.html

# COPY source destination
COPY testIndex.html /usr/share/nginx/html/index.html
```

- COPY '[source]'  '[destination]' => source의 파일을 destination 파일로 붙여넣기
- 더 나아가기 ) 이 source 와 데스티네이션의 경로를 어떻게 작성하는지 확인하자
  우선 testIndex.html 은 Dockerfile 하고 같은 경로라서 별다른 문자열이 없고
  nginx 컨테이너는 / 로 시작 됐음을 알수 있다. 

```bash
jaebukbuk@jaebukbukubuntu24:~$ docker build -t web_server_image .
[+] Building 1.8s (10/10) FINISHED                        docker:default
 => [internal] load build definition from Dockerfile       0.0s
 => => transferring dockerfile: 221B                       0.0s 
 => [1/4] FROM docker.io/library/nginx:1.27.0@sha256:98f8ec75657d21b924fe4f69b6b9bff2f6550ea48838af479d8894a852000e40                    0.0s 
 => CACHED [2/4] RUN apt-get update             0.0s
 => CACHED [3/4] RUN apt-get -y install vim     0.0s
 => [4/4] COPY testIndex.html /usr/share/nginx/html/index.html     0.0s
 => exporting to image                                             0.0s
 => => exporting layers                                            0.0s
 => => writing image sha256:f634073ffc7af1cadf312777ad74ccf8b8062a25a8cd91076eb10947c367f699
 => => naming to docker.io/library/web_server_image                0.0s
```

- copy 가 정상적으로 동작 한것을 알수 있다.
- 하지만 오너쉽 문제로 해당 명령어가 실패할수이쓴데

```bash
# 이게 권한 문제 때문에 안될때
RUN chown nginx:nginx /usr/share/nginx/html/index.html
```

- 이때는 해당 권한 부여해 주자 user:group
