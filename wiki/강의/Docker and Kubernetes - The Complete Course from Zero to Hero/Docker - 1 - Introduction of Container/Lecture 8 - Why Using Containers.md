📌 스크립트 번역  
  
이제 Docker를 어떻게 사용하는지 본격적으로 들어가기 전에, Docker가 실제로 우리에게 무엇을 해주는지 이해하는 것이 합리적입니다.    
즉, 컨테이너를 사용하는 가치가 무엇인지부터 짚고 넘어가야 합니다.    
  
이를 위해 한 걸음 물러서서, 컨테이너 없이 애플리케이션을 어떻게 빌드하고 배포해왔는지 살펴보겠습니다.    
또는 아주 단순한 Node.js 애플리케이션 하나를 배포하려면 실제로 무엇을 해야 하는지 생각해보죠.    
  
우선 완전히 깨끗한(새) 머신에서 시작한다고 가정하겠습니다.    
가장 먼저 해야 할 일은 Node.js 자체가 필요로 하는 의존성(필수 구성요소)을 설치하는 것입니다.    
그다음 그 의존성들이 준비되면, 자바스크립트 파일을 실행하기 위해 Node.js 자체를 설치합니다.    
Node.js 설치가 끝나면, `package.json`과 `package-lock.json` 파일을 확인해서 애플리케이션 의존성을 설치하고, 이후 애플리케이션을 실행할 수 있습니다.    
  
지금 설명은 매우 단순화된 구성입니다.    
물론 실제로는 단계가 더 많을 수 있고, 특히 방금 말한 세 단계 안에서도 더 많은 작업이 들어갈 수 있습니다.    
예를 들어 특정 Node.js 버전을 고정해야 할 수도 있고, TypeScript를 사용한다면 트랜스파일(Transpilation) 같은 중간 단계가 추가될 수도 있습니다.    
  
하지만 보시다시피, 아주 단순한 애플리케이션이라도 깨끗한 머신에서 시작하면 실행까지 몇 가지 단계를 반드시 거쳐야 합니다.    
그리고 이건 Node.js에 대해서만 이야기한 것입니다.    
  
Node.js는 인터프리터 언어이기 때문에, 사전에 코드를 빌드하거나 컴파일하지 않아도 됩니다.    
하지만 Go나 Java 같은 다른 언어는 사전에 코드를 빌드해야 합니다.    
그 자체로 배포 과정에 추가 단계가 더 들어가게 됩니다.    
  
또 한 가지는 Node.js 버전이 달라지는 경우입니다.    
예를 들어 어떤 애플리케이션은 Node 18과 호환되고, 또 다른 애플리케이션은 Node 22의 기능이 필요하다고 해봅시다.    
이 두 애플리케이션을 같은 머신에서 어떻게 실행할까요.    
그리고 서로 다른 Node.js 버전을 어떻게 관리할까요.    
  
게다가 지금까지는 애플리케이션 하나만 이야기했습니다.    
그런데 여러 애플리케이션을 나란히 동시에 실행해야 한다면 어떻게 될까요.    
각 애플리케이션은 각자의 상위(업스트림) 의존성 집합을 갖습니다.    
  
예를 들어 여기에는 Node.js 의존성이 있지만, Java는 Java의 의존성이 있습니다.    
Ruby도 자신만의 의존성이 있고, Go도 자신만의 의존성이 있습니다.    
그런데 이런 의존성들이 서로 충돌하기 시작하면 어떻게 될까요.    
  
네. 보시다시피, 애플리케이션을 실행하는 머신을 관리하는 일이 아주 빠르게 “지옥”이 될 수 있습니다.    
각 머신마다 필요한 소프트웨어를 모두 설치하고, 개별적으로 설정까지 해야 한다면 말이죠.    
  
그래서 DevSecOps는 과거에 대체로 이런 모습이었습니다.    
배포를 위한 스크립트를 작성합니다.    
개발자가 그걸 만들고 나서, “벽 너머로 던집니다(throw over the wall)”.    
그러면 운영팀이 말합니다.    
“잠깐만요. 이거 우리가 설정해둔 머신에서는 제대로 안 돌아가는데요.”    
“스크립트를 수정해 주세요.” 또는 “설정을 조정해야겠네요.”    
  
그리고 이런 사이클, 즉 루프가 며칠, 심지어 몇 주 동안 반복되곤 했습니다.    
결국에는 설치를 마치고 스크립트를 성공적으로 실행해서 애플리케이션을 배포하는 데까지 도달합니다.    
  
다시 말하지만, 이것도 아주 단순화된 이야기입니다.    
실무에서는 단계가 훨씬 더 많고 훨씬 더 복잡합니다.    
하지만 이 짧은 논의만으로도 컨테이너가 어디에서 역할을 할 수 있는지 이해하는 데 도움이 되었으면 합니다.    
  
좋습니다.    
그럼 컨테이너는 어떻게 이 문제를 해결해줄까요.    
컨테이너는 어떤 언어로 작성된 애플리케이션이든 실행에 필요한 모든 의존성과 설정을 캡슐화합니다.    
그래서 외부에서 보면 깨끗하고 안정적이며 통일된 인터페이스를 제공합니다.    
겉보기에는 모두 비슷하게 보이고, 실행 방식도 거의 비슷합니다.    
  
이제 컨테이너 사용의 장점을 몇 가지 살펴봅시다.    
  
첫째, 설정이 단순해집니다.    
이전 논의에서 보았던 혼란(카오스)을 기억하시죠.    
서로 다른 의존성이 한 머신에 나란히 설치되고, 호환되는 버전을 찾기 위해 많은 미세 조정이 필요했습니다.    
컨테이너는 필요한 의존성을 모두 내부에 캡슐화하므로 이런 일이 필요하지 않습니다.    
  
둘째, 이식성(portability)이 있습니다.    
컨테이너 런타임이 있는 한 머신에서 컨테이너를 가져와, 컨테이너 런타임이 있는 다른 머신에서 그대로 실행할 수 있습니다.    
그리고 다른 머신에서 추가로 해야 할 설정은 사실상 거의 \(0\)에 가깝습니다.    
  
강의 내내 이 모습을 여러 번 보게 될 것입니다.    
레지스트리에 저장된 이미지를 실행할 때, 여러분이 하는 일이 바로 이것입니다.    
즉, 이미지를 가져와서 내 머신에서 실행하는데, 사전에 그 이미지에 대해 별도 설정을 하지 않습니다.    
Docker나 다른 컨테이너 런타임만 실행 중이라면, 미리 준비할 것 없이 이미지 기반으로 컨테이너를 시작할 수 있습니다.    
  
셋째, 일관된 환경(consistent environments)을 얻습니다.    
컨테이너는 모든 의존성을 캡슐화하고, 그 내용은 ‘이미지(image)’라는 형태로 명확히 정의됩니다.    
그 이미지를 몇 번이고 사용해 새 컨테이너를 만들어도, 컨테이너들은 동일한 지시사항을 따르기 때문에 항상 똑같이 동작하고 똑같이 생깁니다.    
  
넷째, 격리(isolation)입니다.    
컨테이너를 어떤 네트워크에서 실행할지에 대해 많은 제어권을 가질 수 있습니다.    
또 컨테이너가 실행되는 공간(네트워크/환경)과 호스트 머신 사이에 좋은 수준의 격리를 보장할 수 있습니다.    
  
다섯째, 가상 머신 대비 효율성(efficiency) 이점이 있습니다.    
가상 머신은 강의 후반에 조금 더 다루며, 컨테이너와 어떻게 비교되는지도 보겠습니다.    
하지만 컨테이너는 게스트 OS(Guest Operating System)가 필요하지 않기 때문에 효율성이 좋아집니다.    
즉, 같은 머신에서 하드웨어를 덜 소모하면서 더 많은 컨테이너를 실행할 수 있습니다.    
  
여섯째, 더 나은 자원 제어(resource control)입니다.    
컨테이너는 특정 컨테이너가 사용할 수 있는 CPU와 메모리를 매우 세밀하게 조정할 수 있습니다.    
예를 들어 메모리를 너무 많이 쓰면 컨테이너를 종료하도록 제한을 걸 수 있고,    
CPU를 과도하게 쓰면 실행을 제한(throttle)하여 호스트에서 다른 애플리케이션을 위협하지 못하게 만들 수도 있습니다.    
  
마지막으로, 쉽게 확장 가능한 애플리케이션(easily scalable applications)을 얻습니다.    
컨테이너는 안정적인 이미지에 기반해 생성되기 때문에, 수평 확장(horizontal scaling)이 더 쉬워집니다.    
  
좋습니다.    
이제 컨테이너를 도입했을 때 개발(Devs)과 운영(Ops) 작업이 어떻게 보이는지 살펴보겠습니다.    
  
먼저 한 가지 분명히 하고 싶은 점이 있습니다.    
지금처럼 개발과 운영을 구분해 설명한다고 해서, 반드시 두 개의 서로 다른 팀이 있어야 한다는 뜻은 아닙니다.    
전통적으로 개발과 운영이 분리된 조직에서는 두 팀이 있을 수 있지만,    
요즘 많은 회사에서는 DevOps 팀이 흔합니다.    
이는 개발자와 운영 담당자가 함께 앉아 함께 배포한다는 의미입니다.    
그리고 컨테이너는 실제로 그런 협업을 가능하게 해줍니다.    
  
개발 측면에서는 Dockerfile을 작성합니다.    
Dockerfile은 이미지를 만들기 위한 설계도(블루프린트)입니다.    
그다음 이미지를 빌드하고 푸시합니다.    
  
그다음 운영 작업으로 넘어갑니다.    
운영 측면에서는 컨테이너를 배포하기 위한 일부 정보가 필요할 수 있습니다.    
예를 들면 환경 변수나 설정 같은 것들입니다.    
하지만 컨테이너 이미지 안에 실행에 필요한 모든 것이 이미 들어 있으므로, 그게 거의 전부입니다.    
즉, 컨테이너를 실행할 머신에 특정 소프트웨어를 별도로 설치할 필요가 거의 없습니다.    
  
배포에 필요한 설정과 정보만 있으면, 컨테이너를 바로 실행해서 애플리케이션을 배포할 수 있습니다.    
그래서 컨테이너는 소프트웨어 애플리케이션을 배포하고 실행해야 할 때 우리의 삶을 훨씬 더 쉽게 만들어줍니다.    
이것이 컨테이너가 오늘날 매우 보편적이고 흔한 기술이 된 이유 중 하나입니다.    
  
정말 기대됩니다.    
컨테이너에 대해 더 배우고 싶다면, 지금 잘 찾아오셨습니다.    
그럼 잠깐 쉬었다가 다음 강의에서 다시 만나요.    
  
![Pasted image 20260128000208.png](../../../99.%20File/Pasted%20image%2020260128000208.png)![Pasted image 20260128000214.png](../../../99.%20File/Pasted%20image%2020260128000214.png)  
